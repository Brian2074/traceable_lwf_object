"""Flower client adapter for YOLOv8n + FedRep + Feature KD."""

import logging
import os
import pickle
import sys

import flwr as flw
import numpy as np
import torch
from torchvision import transforms

sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from client import Client
from option import args_parser
from utils import setup_seed

logger = logging.getLogger(__name__)


class FedRepFlowerClient(flw.client.NumPyClient):
    """Flower client implementing FedRep body/head split training.

    The body parameters are sent to the server for FedAvg aggregation.
    The head is kept local and never shared.

    Attributes:
        args: Parsed arguments.
        client_id: Client identifier.
        fedrep_client: Underlying ``Client`` instance.
    """

    def __init__(
        self,
        args: object,
        client_id: int,
        train_dataset: object,
        test_dataset: object,
    ) -> None:
        """Initialise the Flower client.

        Args:
            args: Parsed arguments.
            client_id: Client ID.
            train_dataset: Training dataset.
            test_dataset: Test dataset.
        """
        self.args = args
        self.client_id = client_id
        self.fedrep_client = Client(args, train_dataset, test_dataset, client_id)

    def get_parameters(self, config: dict) -> list:
        """Return body parameters as a list of numpy arrays.

        Args:
            config: Flower configuration dict.

        Returns:
            List of numpy arrays (body state dict values).
        """
        body_sd = self.fedrep_client.get_body_state_dict()
        return [v.cpu().numpy() for v in body_sd.values()]

    def set_parameters(self, parameters: list) -> None:
        """Load aggregated body parameters from server.

        Args:
            parameters: List of numpy arrays from server.
        """
        body_sd = self.fedrep_client.get_body_state_dict()
        keys = list(body_sd.keys())
        new_sd = {k: torch.from_numpy(v) for k, v in zip(keys, parameters)}
        self.fedrep_client.load_body_state_dict(new_sd)

    def fit(self, parameters: list, config: dict) -> tuple:
        """Execute one round of FedRep training.

        1. Load aggregated body params from server.
        2. Train body (global) for ``fedrep_body_epochs``.
        3. Train head (local) for ``fedrep_head_epochs``.
        4. Optionally run KD if teacher is available.
        5. Return updated body params.

        Args:
            parameters: Body parameters from server.
            config: Round configuration.

        Returns:
            (parameters, num_examples, metrics) tuple.
        """
        task_id = int(config.get("task_id", 1))
        new_nc = int(config.get("num_classes", self.args.numclass * task_id))

        print(f"Client {self.client_id}: fit() for task {task_id}")

        # Load body from server
        self.set_parameters(parameters)

        # Prepare for new task if needed
        if task_id > self.fedrep_client.max_task:
            self.fedrep_client.prepare_new_task(task_id, new_nc)

        # YOLOv8 uses a yaml file path instead of DataLoaders
        # Assuming the downloaded dataset sits in datasets/spscd_coco_yolo/
        # and has client-specific configs generated by download_dataset.py
        yaml_path = f"datasets/spscd_coco_yolo/client_{self.client_id}.yaml"
        if not os.path.exists(yaml_path):
            logger.error(f"Dataset config not found: {yaml_path}")
            # Fallback to a default if testing or misconfigured
            yaml_path = "datasets/spscd_coco_yolo/data.yaml"

        # FedRep: Train body
        self.fedrep_client.train_body(task_id, yaml_path)

        # FedRep: Train head
        self.fedrep_client.train_head(task_id, yaml_path)

        # KD for subsequent tasks
        if task_id > 1:
            self.fedrep_client.train_with_kd(task_id, yaml_path)

        # Return updated body params (hardcoded 1000 examples for simplicity)
        return self.get_parameters(config), 1000, {}

    def evaluate(self, parameters: list, config: dict) -> tuple:
        """Evaluate the model.

        Args:
            parameters: Body parameters from server.
            config: Evaluation configuration.

        Returns:
            (loss, num_examples, metrics) tuple.
        """
        self.set_parameters(parameters)

        task_id = int(config.get("task_id", 1))
        yaml_path = f"datasets/spscd_coco_yolo/client_{self.client_id}.yaml"
        if not os.path.exists(yaml_path):
            yaml_path = "datasets/spscd_coco_yolo/data.yaml"

        try:
            val_metric = self.fedrep_client.validate(yaml_path, task_id)
            return 0.0, 100, {"val_metric": float(val_metric)}
        except Exception as e:
            logger.error("Evaluation failed for client %d: %s", self.client_id, e)
            return 0.0, 100, {"val_metric": 0.0}


def main() -> None:
    """Start the Flower client."""
    args = args_parser()
    setup_seed(args.seed)

    print(f"\n{'=' * 60}")
    print(f"  FedRep Flower Client: {args.exp_name}")
    print(f"  Model: {args.model}, Client ID: {args.client_id}")
    print(f"  AMP: {args.use_amp}")
    print(f"{'=' * 60}\n")

    # TODO: Set up actual datasets
    train_dataset = None
    test_dataset = None

    client = FedRepFlowerClient(args, args.client_id, train_dataset, test_dataset)

    flw.client.start_client(
        server_address=args.server_address,
        client=client.to_client(),
    )


if __name__ == "__main__":
    main()
